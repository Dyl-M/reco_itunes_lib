---
title: "Exploration & exploitation (restreinte) de données d'une bibliothèque iTunes (.xlm)"
subtitle: "Projet Personnel [R / Python]"
author: "MONFRET Dylan"
code_folding : "none"
output:
  html_notebook:
    theme: journal
    code_folding : show
    css: 'Style/style_css.css'
  pdf_document: default
---

# INTRODUCTION

<u>Note pour moi même</u>  
Retire ce fond avec le logo des établissements, la vérité c'est pas très beau...

> Début du projet : 6 novembre 2019  
> Dernière modif. : 18 novembre 2019  
> Fin du projet : -

> Ouais ouais. J'ai que ça à faire, réviser R et Python en même temps, les veilles d'examens qui n'ont rien à voir avec ça ou presque. Enfin bref. L'objectif (si on peut appeler ça un *"objectif"*) c'est de travailler sur les données d'une bibliothèque iTunes pour en déduire des choses sur les habitudes d'écoute d'un utilisateur (par les genres musicaux, les artistes, les années des pistes, le nombre d'écoute, etc.) ; en utilisant un peut de Python et un peu de R (ET SURTOUT PAS DE SAS, *VADE RETRO SATANAS*), histoire de ce faciliter la tâche selon les situations. Par exemple, traiter le fichier xml... Bah, on verra bien ci-dessous, c'est plus facile de faire des trucs selon le language. J'espère faire un truc de plus en plus propre au fur-et-à-mesure que je vais apprendre des choses sur les deux languages et sur RStudio. En attendant, voici du code sale. :)

[insérer ici le lien du tweet ou j'ai échoué à lire le fichier xml de mon iTunes parce que j'étais un p'tit peu con avant. Oui, parce que c'est pas ma première tentative, j'ai fait crash mon PC en mai dernier à cause de mon ignorance. ^^]

    Note: Il y a un premier r-chunck en tout premier que je cache parce qu'il est moche mais il reste très important : il gère la mise en forme des autres chunk pour le rendu en .html du RNotebook, et il permet la bonne exécution du (ou des ?) bout de script en Python. Voilà. oui.

```{r, echo = FALSE}
knitr::opts_knit$set(tidy = TRUE)
library(reticulate)
use_python("/user/local/bin/python")
```

# PHASE 1 - Conversion des données : de `.xlm` à `.csv` (Python)

> On va résumer l'affaire après le script pour ne pas prendre le risque de commenter à l'intérieur du chunck python étant donner que j'ai eu des buggs en essayant des trucs (copy-paste d'un script à ici), et je ne sais pas vraiment pourquoi ça a pas marché (lol). Est-ce que j'avais aussi un peu la flemme ? Très certainement.  

> Donc tout le script est disponible ici, non-commenté, mais plus toujours lisible qu'une correction de prof. Y'a vraiment rien de mystique, c'est la partie qui nous permet d'obtenir une base de données des musiques de la bibliothèque au format .csv, c'est plus simple de passer par Python en l'occurence (ou peut-être que je suis juste très mauvais), grâce à un petit package magique dont on parlera après.

```{python}
from libpytunes import Library
from datetime import datetime
from time import mktime
import csv

# __ DEFINITION DE FONCTIONS LOCALES __

def itunes_lib_xml_to_lst(xml_path="C:/Users/USER/Music/iTunes/iTunes Music Library.xml"):
    biblio = Library(xml_path)
    itunes_data_ld = []
    i = 0
    for song in biblio.songs.values():
        i += 1
        if song.play_count is None:
            count = 0
        else:
            count = song.play_count
        itunes_data_ld.append(
            {"Track_ID": "T{:04d}".format(i), "Name": song.name, "Album": song.album, "Artist": song.artist,
             "Album_Artist": song.album_artist, "Genre": song.genre, "Year": song.year,
             "Date_Added": datetime.fromtimestamp(mktime(song.date_added)),
             "Group": song.grouping, "Play_Count": count})
    return itunes_data_ld


def itunes_lib_xml_to_csv(csv_name="iTunes_Library.csv",
                          xml_path="C:/Users/USER/Music/iTunes/iTunes Music Library.xml"):
    lst_data_base = itunes_lib_xml_to_lst(xml_path)
    col_names = lst_data_base[0].keys()
    try:
        with open(csv_name, 'w', encoding="utf-8-sig", newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=col_names, delimiter=";")
            writer.writeheader()
            for data in lst_data_base:
                writer.writerow(data)
    except IOError:
        print("I/O error")

# __ CORPS PRINCIPAL DU PROGRAMME __

# mon_itunes = itunes_lib_xml_to_lst()
# print(mon_itunes)

itunes_lib_xml_to_csv()

# """ - LISTE DES ELEMENTS TROUVABLES DANS L'OBJET DE TYPE /songs/ """

# name(String)
# album = None(String)
# artist(String)
# album_artist(String)
# genre = None(String)
# year = None(Integer)
# date_added = None(Time)
# play_count = None(Integer)
# grouping = None(String)

# comments = None(String)
# persistent_id(String)
# composer = None(String)
# kind = None(String)
# size = None(Integer)
# total_time = None(Integer)
# track_number = None(Integer)
# track_count = None(Integer)
# disc_number = None(Integer)
# disc_count = None(Integer)
# date_modified = None(Time)
# bit_rate = None(Integer)
# sample_rate = None(Integer)
# rating = None(Integer)
# album_rating = None(Integer)
# location = None(String)
# location_escaped = None(String)
# compilation = False(Boolean)
# lastplayed = None(Time)
# skip_count = None(Integer)
# skip_date = None(Time)
# length = None(Integer)
# work = None(String)
# movement_name = None(String)
# movement_number = None(Integer)
# movement_count = None(Integer)
# loved = False(Boolean)
# album_loved = False(Boolean)
```
<br>
<center><u>**CE QUE FAIT LE SCRIPT**</u></center>
<br>

  - Le package `datetime` etant un classique, on ne va pas s'attarder dessus.
  
  - Le package `libpytunes` a été conçu par un internaut et est disponible sur GitHub [INSERER LIEN VERS PACKAGE et NOM CREATEUR], c'est le package clé qui permet de gérer tous les éléments du fichier XLM. Par lecture du chemin de fichier vers le `.xlm`, il crée un objet (je crois... à vérifier donc ^^') contenant les infos sur les playlists, les morceaux, les podcasts, etc. Un vrai plaisir, on n'as plus qu'à suffixer l'objet par `.songs` pour obtenir une liste de dictionnaire avec en clé un ID de morceau et en valeur un object contenant tous ce qu'on veut (cf. liste complète des éléments en fin de script).
  
  - `unicodecsv` : [PROCHAINEMENT]
  
  - `time` / `mktime` : [PROCHAINEMENT]
  
  - `itunes_lib_xml_to_lst` : [PROCHAINEMENT]
  
  - `itunes_lib_xml_to_csv` : [PROCHAINEMENT OUAIS J'AI LA FLEMME TU SAIS LIRE DU PYTHON AU PIRE]

# PHASE 2 - Importation des données pour traitement (R)

> Bon. Il n'y a techniquement aucun traitement, aucun nettoyage à faire au vu de la qualité d'export de notre base de données en `.csv`. Elle est archi clean (pas comme mon niveau d'orthographe), il faudra juste bien ré-importé les éléments dans un type convenable (genre les dates). Mais c'est easy l'import, vraiment c'est de l'eau en particulier avec les fichiers CSV.

```{r}
setClass('myDate')

setAs("character", "myDate", function(from)
  as.Date(from, format = "%Y-%m-%d %H:%M:%S"))

data <-
  read.csv(
    "iTunes_Library.csv",
    header = TRUE,
    sep = ";",
    encoding = 'UTF-8',
    colClasses = c(
      "X.U.FEFF.Track_ID" = "character",
      "Name" = "character",
      "Album" = "character",
      "Date_Added" = "myDate"
    )
  )

names(data)[1] <- "Track_ID"
```

> P'tit affichage, à l'ancienne.

```{r}
data
```

```{r}
summary(data)
```

```{r}
genres <- data$Genre

Genre_Group <- NULL

for (i in 1:length(genres)) {
  if ((grepl("House|Trance",genres[i]))){
    Genre_Group[i] <- "House / Trance / Hard Style"
  } else if (((grepl("Electronic",genres[i])))) {
    Genre_Group[i] <- "Electronic"
  } else if (((grepl("J-Pop|Japanese",genres[i])))) {
    Genre_Group[i] <- "Japanse Music"
  } else if (((grepl("K-Pop",genres[i])))) {
    Genre_Group[i] <- "Korean Music"
  } else if (((grepl("Pop",genres[i])))) {
    Genre_Group[i] <- "Pop"
  } else if (((grepl("Rock",genres[i])))) {
    Genre_Group[i] <- "Rock"
  } else if (((grepl("Rap|Hip-Hop",genres[i])))) {
    Genre_Group[i] <- "Rap / Hip-Hop"
  } else if (((grepl("Blues|Soul|Jazz",genres[i])))) {
    Genre_Group[i] <- "Blues / Soul / Jazz"
  } else if (((grepl("Reggae|Latine",genres[i])))) {
    Genre_Group[i] <- "Reggae / Reggaeton / Latine"
  } else if (((grepl("Funk|R&B",genres[i])))) {
    Genre_Group[i] <- "Funk / R&B"
  } else if (((grepl("Classique",genres[i])))) {
    Genre_Group[i] <- "Classique"
  } else if (((grepl("Alternative",genres[i])))) {
    Genre_Group[i] <- "Alternative"
  } else {
    Genre_Group[i] <- NA
  }
}

data <- data.frame(data, Genre_Group); rm(i, Genre_Group, genres)
```

```{r}
gr_genre <- data$Genre_Group

Hyp_Group_Genre <- NULL

for (i in 1:length(gr_genre)) {
  if ((grepl("House / Trance / Hard Style|Electronic", gr_genre[i]))) {
    Hyp_Group_Genre[i] <- "Electronic Music"
  } else if (((grepl("Japanse Music|Korean Music", gr_genre[i])))) {
    Hyp_Group_Genre[i] <- "Asian Music"
  } else if (((grepl("Funk / R&B|Blues / Soul / Jazz|Rap / Hip-Hop", gr_genre[i])))) {
    Hyp_Group_Genre[i] <- "US Music"
  } else {
    Hyp_Group_Genre[i] <- "Other / NA"
  }
}

par(mar = c(7, 4, 2, 2) + 0.2)
data <- data.frame(data, Hyp_Group_Genre)
barplot(table(data$Hyp_Group_Genre))
rm(gr_genre, Hyp_Group_Genre, i)
```

```{r}

```


# PHASE 3 - Création de la base de donnée des artistes

# PHASE 4 - AFC des titres sur les Genres / Artistes

# FIN

```{r, echo=FALSE}
save.image()
```
